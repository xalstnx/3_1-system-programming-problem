# 3_1 시스템 프로그래밍 실습과제

## 1.copy_file()
파일을 복사하여 사본을 생성하는 copy_file()함수를 구현하라.
low level function, 즉 open, read, write, close를 이용하여 구현하라.

## 2.chmod a+rX
chmod a+rX와 동일하게 동작하는 프로그램을 stat()과 chmod()를 이용하여 구현하라.
나머지는 모두 구현되어 있으며, chmod_arX 함수만 구현할 것.
chmod a+rX [path] 명령은 다음과 같은 일을 수행한다.
* 모든 읽기 권한 활성화
* 디렉토리에는 모든 실행 권한을 활성화 한다.
* 이미 실행 권한이 있는 파일에 대해 모든 실행 권한을 활성화 한다. 
* 이때, 이미 실행 권한이 있는 파일이라는 의미는 사용자 종류에 상관 없이 하나라도 실행 권한을 가지고 있는 경우를 의미한다.

## 3.getcwd()
getcwd()와 동일한 동작을 실행하는 함수를 구현하라. 
* getcwd()의 성공/실패 여부와 상관 없이, 탐색을 시작한 것과 동일한 디렉토리에 존재해야 함
* 인자가 NULL인 경우는 고려할 필요 없음
* 부모 디렉토리(..)의 각 엔트리를 돌면서 opendir()과 readdir()을 사용하면 현재 작업 디렉토리의 이름을 알 수 있음
* 현재 작업 디렉토리와 동일한 i-노드와 디바이스 번호를 가진 엔트리를 찾으면 현재 디렉토리가 무엇인지 알 수 있음
* 한 번에 한 단계씩 살펴보고, 스캔을 통해 디렉토리 경로를 구축해볼 것
* 부모 디렉토리가 현재와 동일하다면(루트 디렉토리의 경우), 검색 종료 

## 4.myexeclp()
execve()를 이용하여 execlp()를 구현하시오.
기존 execlp()와 겹치지 않도록 myexeclp() 함수로 구현할 것
execlp()는 인자의 길이가 가변적임
* 가변적 인자를 처리해주기 위해서는 stdarg(3)이 필요함 
* 인터넷에서 사용 예 검색해볼 것
* 구현의 편의를 위해 인자의 최대 길이는 MAXARGS를 사용할 것
* 환경변수 PATH로부터 경로명을 가져와 테스트해 볼 것
* 파일이 있는지, 그 파일이 실행 가능한지 테스트해야 함
* 제일 뒤의 경로명부터 테스트해야 함
* 처음 실행할 수 있는 경로명에 있는 실행파일을 사용할 것
* 실패 시 -1 반환

## 5.hello_again(signal)
set이라는 이름의 시그널 세트를 생성하고, 이를 이용하여 프로그램이 ctrl + c로 종료되지 않도록 만드시오.
sigprocmask를 사용할 것

## 6.wake_up(signal)
SIGALRM을 받으면 1초 간격으로 "wake up\n"을 출력하는 프로그램을 작성하시오. 
SIGALRM 시그널의 핸들러가 실행되는 동안 SIGINT를 제외한 모든 시그널을 블럭하시오.
